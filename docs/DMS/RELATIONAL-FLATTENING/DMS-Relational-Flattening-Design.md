# DMS JSON Document Flattening to Relational Tables - Comprehensive Design

## Executive Summary

This document provides a comprehensive design for flattening JSON documents stored in the DMS Documents table into relational tables for backwards compatibility with the legacy ODS/API. The design includes table structures, flattening algorithms, a dynamic extension registration system, testing strategies, and work distribution plans.

## Current State Analysis

### DMS Document Storage
The DMS currently stores all API documents in a single partitioned table:

```sql
CREATE TABLE dms.Document (
  Id BIGINT GENERATED ALWAYS AS IDENTITY,
  DocumentPartitionKey SMALLINT NOT NULL,
  DocumentUuid UUID NOT NULL,
  ResourceName VARCHAR(256) NOT NULL,
  ResourceVersion VARCHAR(64) NOT NULL,
  IsDescriptor BOOLEAN NOT NULL,
  ProjectName VARCHAR(256) NOT NULL,
  EdfiDoc JSONB NOT NULL,  -- The actual JSON document
  SecurityElements JSONB NOT NULL,
  StudentSchoolAuthorizationEdOrgIds JSONB NULL,
  ContactStudentSchoolAuthorizationEdOrgIds JSONB NULL,
  StaffEducationOrganizationAuthorizationEdOrgIds JSONB NULL,
  CreatedAt TIMESTAMP NOT NULL DEFAULT NOW(),
  LastModifiedAt TIMESTAMP NOT NULL DEFAULT NOW(),
  LastModifiedTraceId VARCHAR(128) NOT NULL,
  PRIMARY KEY (DocumentPartitionKey, Id)
) PARTITION BY HASH(DocumentPartitionKey);
```

### Legacy ODS/API Structure
The ODS/API uses normalized relational tables with:
- Core entity tables (Student, School, etc.)
- Child/array tables for collections
- Descriptor tables for enumerations
- Extension tables for custom data
- USI (Unique Surrogate Identifier) pattern for internal relationships

## Schema Architecture

### Schema Separation Strategy

1. **`dms` schema**: Registry tables, infrastructure, and the original Document table
2. **`edfi` schema**: Core Ed-Fi flattened relational tables
3. **Extension schemas**: One schema per extension (e.g., `tpdm`, `sample`)
4. **Hash suffix**: For table names exceeding 63 characters

```sql
-- Create schemas
CREATE SCHEMA IF NOT EXISTS edfi;
CREATE SCHEMA IF NOT EXISTS tpdm;
CREATE SCHEMA IF NOT EXISTS sample;
```

## Extension Registration System

### Design Principles for Extensions

1. **Loose Coupling**: Core flattening logic doesn't know about specific extensions
2. **Dynamic Configuration**: Extensions configured at deployment time
3. **No Core Modifications**: Adding extensions requires no changes to core logic
4. **Schema Isolation**: Extensions use separate schemas instead of table prefixes
5. **MetaEd Generated**: All extension artifacts generated by MetaEd

### Extension Registry Tables

```sql
-- Extension configuration registry (remains in dms schema)
CREATE TABLE dms.extension_registry (
    extension_name VARCHAR(100) PRIMARY KEY,
    schema_name VARCHAR(63) NOT NULL, -- Schema for extension tables
    is_enabled BOOLEAN NOT NULL DEFAULT true,
    priority INT NOT NULL DEFAULT 100, -- For ordering when multiple extensions modify same resource
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

-- Resource flattening function registry
CREATE TABLE dms.resource_flattening_registry (
    id SERIAL PRIMARY KEY,
    resource_name VARCHAR(256) NOT NULL,
    extension_name VARCHAR(100), -- NULL for core Ed-Fi resources
    flattening_function VARCHAR(500) NOT NULL, -- Fully qualified function name
    target_table VARCHAR(500) NOT NULL, -- Schema-qualified table name
    priority INT NOT NULL DEFAULT 100,
    CONSTRAINT resource_flattening_unique UNIQUE(resource_name, extension_name)
);

-- Extension flattening function registry for extending core resources
CREATE TABLE dms.extension_flattening_registry (
    id SERIAL PRIMARY KEY,
    core_resource_name VARCHAR(256) NOT NULL,
    extension_name VARCHAR(100) NOT NULL,
    flattening_function VARCHAR(500) NOT NULL,
    priority INT NOT NULL DEFAULT 100,
    CONSTRAINT extension_flattening_unique UNIQUE(core_resource_name, extension_name),
    CONSTRAINT extension_flattening_fk FOREIGN KEY (extension_name) 
        REFERENCES dms.extension_registry(extension_name)
);

-- Table name mapping for hash-shortened names
CREATE TABLE dms.table_name_registry (
    actual_table_name VARCHAR(63) PRIMARY KEY,
    schema_name VARCHAR(63) NOT NULL,
    logical_table_name VARCHAR(255) NOT NULL,
    name_hash VARCHAR(8) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    CONSTRAINT table_name_registry_unique UNIQUE(schema_name, logical_table_name)
);

-- Indexes for performance
CREATE INDEX IX_resource_flattening_resource ON dms.resource_flattening_registry(resource_name);
CREATE INDEX IX_extension_flattening_resource ON dms.extension_flattening_registry(core_resource_name);
```

## Core Relational Table Design

### Design Principles

1. **Maintain Document/Relational Duality**: Keep the existing Document table while synchronizing to relational tables
2. **Avoid JSON Columns**: Pure relational design without JSON or full-text columns
3. **Natural Key Preservation**: Maintain Ed-Fi natural keys alongside DMS document references
4. **Extension Support via Typed Tables**: Support extensions through specific typed tables only
5. **Composite Key Handling**: Map multi-element references to composite foreign keys
6. **Array Flattening**: Separate tables for each array/collection type
7. **Partitioning Awareness**: Maintain partitioning strategy for performance
8. **Schema Separation**: Use `edfi` schema for core tables, separate schemas for extensions
9. **Name Length Management**: Use hash suffixes for table/constraint names exceeding 63 characters

### Core Entity Tables

#### 1. Student Table
```sql
CREATE TABLE edfi.Student (
    -- DMS Reference
    DocumentId BIGINT NOT NULL,
    DocumentPartitionKey SMALLINT NOT NULL,
    DocumentUuid UUID NOT NULL,
    
    -- Natural Key
    StudentUniqueId VARCHAR(32) NOT NULL,
    
    -- Core Attributes
    FirstName VARCHAR(75) NOT NULL,
    MiddleName VARCHAR(75) NULL,
    LastSurname VARCHAR(75) NOT NULL,
    GenerationCodeSuffix VARCHAR(10) NULL,
    MaidenName VARCHAR(75) NULL,
    PersonalTitlePrefix VARCHAR(30) NULL,
    PreferredFirstName VARCHAR(75) NULL,
    PreferredLastSurname VARCHAR(75) NULL,
    
    -- Birth Information
    BirthDate DATE NOT NULL,
    BirthCity VARCHAR(30) NULL,
    BirthStateAbbreviationDescriptorId INT NULL,
    BirthCountryDescriptorId INT NULL,
    BirthInternationalProvince VARCHAR(150) NULL,
    BirthSexDescriptorId INT NULL,
    
    -- Other Attributes
    CitizenshipStatusDescriptorId INT NULL,
    DateEnteredUS DATE NULL,
    MultipleBirthStatus BOOLEAN NULL,
    BirthOrder INT NULL,
    
    -- DMS Metadata
    CreatedAt TIMESTAMP NOT NULL,
    LastModifiedAt TIMESTAMP NOT NULL,
    LastModifiedTraceId VARCHAR(128) NOT NULL,
    
    CONSTRAINT Student_PK PRIMARY KEY (DocumentPartitionKey, DocumentId),
    CONSTRAINT Student_UK_StudentUniqueId UNIQUE (StudentUniqueId),
    CONSTRAINT Student_FK_Document FOREIGN KEY (DocumentPartitionKey, DocumentId) 
        REFERENCES dms.Document(DocumentPartitionKey, Id) ON DELETE CASCADE
);

-- Performance indexes
CREATE INDEX IX_Student_StudentUniqueId ON edfi.Student(StudentUniqueId);
CREATE INDEX IX_Student_DocumentUuid ON edfi.Student(DocumentUuid);
```

#### 2. EducationOrganization Base Table
```sql
CREATE TABLE edfi.EducationOrganization (
    -- DMS Reference
    DocumentId BIGINT NOT NULL,
    DocumentPartitionKey SMALLINT NOT NULL,
    DocumentUuid UUID NOT NULL,
    
    -- Natural Key
    EducationOrganizationId BIGINT NOT NULL,
    
    -- Discriminator for polymorphic types
    EducationOrganizationType VARCHAR(50) NOT NULL, -- 'School', 'LocalEducationAgency', etc.
    
    -- Common Properties
    NameOfInstitution VARCHAR(75) NOT NULL,
    ShortNameOfInstitution VARCHAR(75) NULL,
    WebSite VARCHAR(255) NULL,
    OperationalStatusDescriptorId INT NULL,
    
    -- DMS Metadata
    CreatedAt TIMESTAMP NOT NULL,
    LastModifiedAt TIMESTAMP NOT NULL,
    LastModifiedTraceId VARCHAR(128) NOT NULL,
    
    CONSTRAINT EducationOrganization_PK PRIMARY KEY (DocumentPartitionKey, DocumentId),
    CONSTRAINT EducationOrganization_UK_EdOrgId UNIQUE (EducationOrganizationId),
    CONSTRAINT EducationOrganization_FK_Document FOREIGN KEY (DocumentPartitionKey, DocumentId) 
        REFERENCES dms.Document(DocumentPartitionKey, Id) ON DELETE CASCADE
);
```

#### 3. School Table (Inherits from EducationOrganization)
```sql
CREATE TABLE edfi.School (
    -- DMS Reference (matches EducationOrganization)
    DocumentId BIGINT NOT NULL,
    DocumentPartitionKey SMALLINT NOT NULL,
    
    -- School-specific Properties
    SchoolTypeDescriptorId INT NULL,
    CharterStatusDescriptorId INT NULL,
    TitleIPartASchoolDesignationDescriptorId INT NULL,
    MagnetSpecialProgramEmphasisSchoolDescriptorId INT NULL,
    AdministrativeFundingControlDescriptorId INT NULL,
    InternetAccessDescriptorId INT NULL,
    CharterApprovalAgencyTypeDescriptorId INT NULL,
    CharterApprovalSchoolYear SMALLINT NULL,
    
    -- Parent Reference
    LocalEducationAgencyId BIGINT NULL,
    
    CONSTRAINT School_PK PRIMARY KEY (DocumentPartitionKey, DocumentId),
    CONSTRAINT School_FK_EducationOrganization FOREIGN KEY (DocumentPartitionKey, DocumentId) 
        REFERENCES edfi.EducationOrganization(DocumentPartitionKey, DocumentId) ON DELETE CASCADE
);
```

#### 4. StudentSchoolAssociation Table
```sql
CREATE TABLE edfi.StudentSchoolAssociation (
    -- DMS Reference
    DocumentId BIGINT NOT NULL,
    DocumentPartitionKey SMALLINT NOT NULL,
    DocumentUuid UUID NOT NULL,
    
    -- Natural Key Components (from references)
    StudentUniqueId VARCHAR(32) NOT NULL,
    SchoolId BIGINT NOT NULL,
    EntryDate DATE NOT NULL,
    
    -- Required Attributes
    EntryGradeLevelDescriptorId INT NOT NULL,
    
    -- Optional Attributes
    EntryTypeDescriptorId INT NULL,
    ExitWithdrawDate DATE NULL,
    ExitWithdrawTypeDescriptorId INT NULL,
    ResidencyStatusDescriptorId INT NULL,
    PrimarySchool BOOLEAN NULL,
    EmployedWhileEnrolled BOOLEAN NULL,
    ClassOfSchoolYear SMALLINT NULL,
    EducationOrganizationId BIGINT NULL,
    GraduationPlanTypeDescriptorId INT NULL,
    GraduationSchoolYear SMALLINT NULL,
    FullTimeEquivalency DECIMAL(5,4) NULL,
    TermCompletionIndicator BOOLEAN NULL,
    
    -- Calendar Reference
    CalendarCode VARCHAR(60) NULL,
    SchoolYear SMALLINT NULL,
    
    -- Other Attributes
    RepeatGradeIndicator BOOLEAN NULL,
    SchoolChoiceTransfer BOOLEAN NULL,
    EntryGradeLevelReasonDescriptorId INT NULL,
    
    -- DMS Metadata
    CreatedAt TIMESTAMP NOT NULL,
    LastModifiedAt TIMESTAMP NOT NULL,
    LastModifiedTraceId VARCHAR(128) NOT NULL,
    
    CONSTRAINT StudentSchoolAssociation_PK PRIMARY KEY (DocumentPartitionKey, DocumentId),
    CONSTRAINT StudentSchoolAssociation_UK UNIQUE (StudentUniqueId, SchoolId, EntryDate),
    CONSTRAINT StudentSchoolAssociation_FK_Document FOREIGN KEY (DocumentPartitionKey, DocumentId) 
        REFERENCES dms.Document(DocumentPartitionKey, Id) ON DELETE CASCADE
);

-- Performance indexes
CREATE INDEX IX_StudentSchoolAssociation_Student ON edfi.StudentSchoolAssociation(StudentUniqueId);
CREATE INDEX IX_StudentSchoolAssociation_School ON edfi.StudentSchoolAssociation(SchoolId);
```

### Array/Collection Tables

#### 5. Student Address Table
```sql
CREATE TABLE edfi.StudentAddress (
    -- Parent Reference
    StudentDocumentId BIGINT NOT NULL,
    StudentDocumentPartitionKey SMALLINT NOT NULL,
    
    -- Array Item Key
    AddressTypeDescriptorId INT NOT NULL,
    
    -- Address Fields
    StreetNumberName VARCHAR(150) NOT NULL,
    ApartmentRoomSuiteNumber VARCHAR(50) NULL,
    BuildingSiteNumber VARCHAR(20) NULL,
    City VARCHAR(30) NOT NULL,
    StateAbbreviationDescriptorId INT NOT NULL,
    PostalCode VARCHAR(17) NOT NULL,
    NameOfCounty VARCHAR(30) NULL,
    CountyFIPSCode VARCHAR(5) NULL,
    CountryDescriptorId INT NULL,
    Latitude VARCHAR(20) NULL,
    Longitude VARCHAR(20) NULL,
    LocaleDescriptorId INT NULL,
    
    -- Period Support
    BeginDate DATE NULL,
    EndDate DATE NULL,
    
    -- Array Order
    SequenceNumber INT NOT NULL DEFAULT 0,
    
    CONSTRAINT StudentAddress_PK PRIMARY KEY (StudentDocumentPartitionKey, StudentDocumentId, AddressTypeDescriptorId),
    CONSTRAINT StudentAddress_FK_Student FOREIGN KEY (StudentDocumentPartitionKey, StudentDocumentId) 
        REFERENCES edfi.Student(DocumentPartitionKey, DocumentId) ON DELETE CASCADE
);
```

#### 6. School Grade Levels Table
```sql
CREATE TABLE edfi.SchoolGradeLevel (
    -- Parent Reference
    SchoolDocumentId BIGINT NOT NULL,
    SchoolDocumentPartitionKey SMALLINT NOT NULL,
    
    -- Array Item
    GradeLevelDescriptorId INT NOT NULL,
    
    -- Array Order
    SequenceNumber INT NOT NULL DEFAULT 0,
    
    CONSTRAINT SchoolGradeLevel_PK PRIMARY KEY (SchoolDocumentPartitionKey, SchoolDocumentId, GradeLevelDescriptorId),
    CONSTRAINT SchoolGradeLevel_FK_School FOREIGN KEY (SchoolDocumentPartitionKey, SchoolDocumentId) 
        REFERENCES edfi.School(DocumentPartitionKey, DocumentId) ON DELETE CASCADE
);
```

#### 7. StudentSchoolAssociation Education Plans Table
```sql
CREATE TABLE edfi.StudentSchoolAssociationEducationPlan (
    -- Parent Reference
    StudentSchoolAssociationDocumentId BIGINT NOT NULL,
    StudentSchoolAssociationDocumentPartitionKey SMALLINT NOT NULL,
    
    -- Array Item
    EducationPlanDescriptorId INT NOT NULL,
    
    -- Array Order
    SequenceNumber INT NOT NULL DEFAULT 0,
    
    -- Constraint names > 63 chars will be automatically shortened by MetaEd generation
    CONSTRAINT StudentSchoolAssociationEducationPlan_PK 
        PRIMARY KEY (StudentSchoolAssociationDocumentPartitionKey, StudentSchoolAssociationDocumentId, EducationPlanDescriptorId),
    CONSTRAINT StudentSchoolAssociationEducationPlan_FK_SSA 
        FOREIGN KEY (StudentSchoolAssociationDocumentPartitionKey, StudentSchoolAssociationDocumentId) 
        REFERENCES edfi.StudentSchoolAssociation(DocumentPartitionKey, DocumentId) ON DELETE CASCADE
);
```

### Descriptor Management

#### 8. Descriptor Table
```sql
CREATE TABLE edfi.Descriptor (
    DescriptorId INT GENERATED ALWAYS AS IDENTITY,
    Namespace VARCHAR(255) NOT NULL,
    CodeValue VARCHAR(50) NOT NULL,
    ShortDescription VARCHAR(75) NOT NULL,
    Description VARCHAR(1024) NULL,
    
    -- DMS Document Reference (for descriptors stored as documents)
    DocumentId BIGINT NULL,
    DocumentPartitionKey SMALLINT NULL,
    DocumentUuid UUID NULL,
    
    CreatedAt TIMESTAMP NOT NULL DEFAULT NOW(),
    LastModifiedAt TIMESTAMP NOT NULL DEFAULT NOW(),
    
    CONSTRAINT Descriptor_PK PRIMARY KEY (DescriptorId),
    CONSTRAINT Descriptor_UK UNIQUE (Namespace, CodeValue)
);

-- Lookup index
CREATE INDEX IX_Descriptor_Namespace_CodeValue ON edfi.Descriptor(Namespace, CodeValue);
```

## Extension Table Examples

### TPDM Extension Tables (in tpdm schema)

```sql
-- TPDM adds a new Candidate resource
CREATE TABLE tpdm.Candidate (
    -- DMS Reference
    DocumentId BIGINT NOT NULL,
    DocumentPartitionKey SMALLINT NOT NULL,
    DocumentUuid UUID NOT NULL,
    
    -- Natural Key
    CandidateIdentifier VARCHAR(32) NOT NULL,
    
    -- TPDM Candidate Attributes
    FirstName VARCHAR(75) NOT NULL,
    LastSurname VARCHAR(75) NOT NULL,
    SexDescriptorId INT NULL,
    BirthDate DATE NULL,
    HispanicLatinoEthnicity BOOLEAN NULL,
    EconomicDisadvantaged BOOLEAN NULL,
    FirstGenerationStudent BOOLEAN NULL,
    PersonId VARCHAR(32) NULL,
    
    -- DMS Metadata
    CreatedAt TIMESTAMP NOT NULL,
    LastModifiedAt TIMESTAMP NOT NULL,
    LastModifiedTraceId VARCHAR(128) NOT NULL,
    
    CONSTRAINT Candidate_PK PRIMARY KEY (DocumentPartitionKey, DocumentId),
    CONSTRAINT Candidate_UK UNIQUE (CandidateIdentifier),
    CONSTRAINT Candidate_FK_Document FOREIGN KEY (DocumentPartitionKey, DocumentId) 
        REFERENCES dms.Document(DocumentPartitionKey, Id) ON DELETE CASCADE
);

-- TPDM extension to Student
CREATE TABLE tpdm.StudentExtension (
    -- Parent Reference
    StudentDocumentId BIGINT NOT NULL,
    StudentDocumentPartitionKey SMALLINT NOT NULL,
    
    -- TPDM-specific fields
    GenderDescriptorId INT NULL,
    HispanicLatinoEthnicity BOOLEAN NULL,
    OldEthnicityDescriptorId INT NULL,
    SexDescriptorId INT NULL,
    
    CONSTRAINT StudentExtension_PK PRIMARY KEY (StudentDocumentPartitionKey, StudentDocumentId),
    CONSTRAINT StudentExtension_FK_Student FOREIGN KEY (StudentDocumentPartitionKey, StudentDocumentId) 
        REFERENCES edfi.Student(DocumentPartitionKey, DocumentId) ON DELETE CASCADE
);

-- Example of a long table name that would use hash suffix
-- Logical name: CandidateEducatorPreparationProgramAssociationQualifications (66 chars)
-- Actual name with hash (automatically resolved by dms.resolve_table_name()):
CREATE TABLE tpdm.CandidateEducatorPreparationProgramAssoc_7a8b9c (
    -- Parent Reference
    CandidateEducatorPreparationProgramAssociationDocumentId BIGINT NOT NULL,
    CandidateEducatorPreparationProgramAssociationDocumentPartitionKey SMALLINT NOT NULL,
    
    -- Qualification fields
    QualificationDescriptorId INT NOT NULL,
    QualificationDate DATE NULL,
    QualificationStatus VARCHAR(50) NULL,
    
    -- Array Order
    SequenceNumber INT NOT NULL DEFAULT 0,
    
    -- Constraint names > 63 chars will be automatically shortened by MetaEd generation
    CONSTRAINT CandidateEducatorPreparationProgramAssociationQualif_PK 
        PRIMARY KEY (CandidateEducatorPreparationProgramAssociationDocumentPartitionKey, 
                     CandidateEducatorPreparationProgramAssociationDocumentId, 
                     QualificationDescriptorId),
    CONSTRAINT CandidateEducatorPreparationProgramAssociationQualif_FK 
        FOREIGN KEY (CandidateEducatorPreparationProgramAssociationDocumentPartitionKey, 
                     CandidateEducatorPreparationProgramAssociationDocumentId) 
        REFERENCES tpdm.CandidateEducatorPreparationProgramAssociation(DocumentPartitionKey, DocumentId) ON DELETE CASCADE
);

-- Register the hash mapping (done automatically by resolve_table_name function)
INSERT INTO dms.table_name_registry (actual_table_name, schema_name, logical_table_name, name_hash)
VALUES ('CandidateEducatorPreparationProgramAssoc_7a8b9c', 'tpdm', 'CandidateEducatorPreparationProgramAssociationQualifications', '7a8b9c');
```

### Sample Extension Tables (in sample schema)

```sql
-- Sample extension to Student
CREATE TABLE sample.StudentExtension (
    -- Parent Reference
    StudentDocumentId BIGINT NOT NULL,
    StudentDocumentPartitionKey SMALLINT NOT NULL,
    
    -- Sample-specific fields
    MedicalRecordNumber VARCHAR(50) NULL,
    HasAllergies BOOLEAN NULL,
    EmergencyContactPhone VARCHAR(20) NULL,
    
    CONSTRAINT StudentExtension_PK PRIMARY KEY (StudentDocumentPartitionKey, StudentDocumentId),
    CONSTRAINT StudentExtension_FK_Student FOREIGN KEY (StudentDocumentPartitionKey, StudentDocumentId) 
        REFERENCES edfi.Student(DocumentPartitionKey, DocumentId) ON DELETE CASCADE
);

-- Sample adds a new Pet resource
CREATE TABLE sample.Pet (
    -- DMS Reference
    DocumentId BIGINT NOT NULL,
    DocumentPartitionKey SMALLINT NOT NULL,
    DocumentUuid UUID NOT NULL,
    
    -- Natural Key
    PetName VARCHAR(50) NOT NULL,
    OwnerStudentUniqueId VARCHAR(32) NOT NULL,
    
    -- Pet Attributes
    Species VARCHAR(50) NOT NULL,
    Breed VARCHAR(50) NULL,
    BirthDate DATE NULL,
    
    -- DMS Metadata
    CreatedAt TIMESTAMP NOT NULL,
    LastModifiedAt TIMESTAMP NOT NULL,
    LastModifiedTraceId VARCHAR(128) NOT NULL,
    
    CONSTRAINT Pet_PK PRIMARY KEY (DocumentPartitionKey, DocumentId),
    CONSTRAINT Pet_UK UNIQUE (PetName, OwnerStudentUniqueId),
    CONSTRAINT Pet_FK_Document FOREIGN KEY (DocumentPartitionKey, DocumentId) 
        REFERENCES dms.Document(DocumentPartitionKey, Id) ON DELETE CASCADE
);
```

## Dynamic Document Flattening Algorithm

### Table Name Resolution Function

```sql
CREATE OR REPLACE FUNCTION dms.resolve_table_name(
    p_schema_name VARCHAR,
    p_logical_name VARCHAR
) RETURNS VARCHAR AS $$
DECLARE
    v_actual_name VARCHAR(63);
    v_name_hash VARCHAR(8);
BEGIN
    -- Check if name is within limit
    IF LENGTH(p_logical_name) <= 63 THEN
        RETURN p_logical_name;
    END IF;
    
    -- Look up existing mapping
    SELECT actual_table_name INTO v_actual_name
    FROM dms.table_name_registry
    WHERE schema_name = p_schema_name 
      AND logical_table_name = p_logical_name;
    
    IF v_actual_name IS NOT NULL THEN
        RETURN v_actual_name;
    END IF;
    
    -- Generate new hash-based name
    v_name_hash := LEFT(MD5(p_logical_name), 6);
    v_actual_name := LEFT(p_logical_name, 56) || '_' || v_name_hash;
    
    -- Register the mapping
    INSERT INTO dms.table_name_registry (actual_table_name, schema_name, logical_table_name, name_hash)
    VALUES (v_actual_name, p_schema_name, p_logical_name, v_name_hash);
    
    RETURN v_actual_name;
END;
$$ LANGUAGE plpgsql;
```

### Core Flattening Process with Registry

```sql
CREATE OR REPLACE FUNCTION dms.flatten_document(
    p_document_id BIGINT,
    p_document_partition_key SMALLINT
) RETURNS VOID AS $$
DECLARE
    v_document RECORD;
    v_flattening_function VARCHAR(500);
    v_extension_name VARCHAR(100);
BEGIN
    -- Get document
    SELECT * INTO v_document
    FROM dms.Document
    WHERE Id = p_document_id 
      AND DocumentPartitionKey = p_document_partition_key;
    
    -- Look up flattening function from registry
    -- First check extension resources, then core resources
    SELECT 
        rf.flattening_function,
        rf.extension_name
    INTO 
        v_flattening_function,
        v_extension_name
    FROM dms.resource_flattening_registry rf
    LEFT JOIN dms.extension_registry er ON rf.extension_name = er.extension_name
    WHERE rf.resource_name = v_document.ResourceName
      AND (rf.extension_name IS NULL OR er.is_enabled = true)
    ORDER BY 
        CASE WHEN rf.extension_name IS NOT NULL THEN 0 ELSE 1 END, -- Extensions first
        rf.priority DESC
    LIMIT 1;
    
    IF v_flattening_function IS NOT NULL THEN
        -- Log for debugging
        RAISE DEBUG 'Flattening % using function %', 
            v_document.ResourceName, v_flattening_function;
        
        -- Dynamically execute the registered function
        EXECUTE format('SELECT %s($1, $2)', v_flattening_function) 
        USING v_document, v_document.EdfiDoc;
    ELSE
        -- No handler found - this is OK for unknown resources
        RAISE NOTICE 'No flattening handler registered for resource: %', v_document.ResourceName;
    END IF;
END;
$$ LANGUAGE plpgsql;
```

### Core Resource Flattening with Dynamic Extensions

```sql
CREATE OR REPLACE FUNCTION dms.flatten_student(
    p_document RECORD,
    p_edfi_doc JSONB
) RETURNS VOID AS $$
DECLARE
    v_student_unique_id VARCHAR(32);
    v_descriptor_id INT;
    v_address JSONB;
    v_sequence INT;
    v_extension_function RECORD;
BEGIN
    -- Extract natural key
    v_student_unique_id := p_edfi_doc->>'studentUniqueId';
    
    -- Insert/Update main student record
    INSERT INTO edfi.Student (
        DocumentId,
        DocumentPartitionKey,
        DocumentUuid,
        StudentUniqueId,
        FirstName,
        MiddleName,
        LastSurname,
        GenerationCodeSuffix,
        MaidenName,
        PersonalTitlePrefix,
        PreferredFirstName,
        PreferredLastSurname,
        BirthDate,
        BirthCity,
        BirthStateAbbreviationDescriptorId,
        BirthCountryDescriptorId,
        BirthInternationalProvince,
        BirthSexDescriptorId,
        CitizenshipStatusDescriptorId,
        DateEnteredUS,
        MultipleBirthStatus,
        BirthOrder,
        CreatedAt,
        LastModifiedAt,
        LastModifiedTraceId
    ) VALUES (
        p_document.Id,
        p_document.DocumentPartitionKey,
        p_document.DocumentUuid,
        v_student_unique_id,
        p_edfi_doc->>'firstName',
        p_edfi_doc->>'middleName',
        p_edfi_doc->>'lastSurname',
        p_edfi_doc->>'generationCodeSuffix',
        p_edfi_doc->>'maidenName',
        p_edfi_doc->>'personalTitlePrefix',
        p_edfi_doc->>'preferredFirstName',
        p_edfi_doc->>'preferredLastSurname',
        (p_edfi_doc->>'birthDate')::DATE,
        p_edfi_doc->>'birthCity',
        dms.get_descriptor_id(p_edfi_doc->>'birthStateAbbreviationDescriptor'),
        dms.get_descriptor_id(p_edfi_doc->>'birthCountryDescriptor'),
        p_edfi_doc->>'birthInternationalProvince',
        dms.get_descriptor_id(p_edfi_doc->>'birthSexDescriptor'),
        dms.get_descriptor_id(p_edfi_doc->>'citizenshipStatusDescriptor'),
        (p_edfi_doc->>'dateEnteredUS')::DATE,
        (p_edfi_doc->>'multipleBirthStatus')::BOOLEAN,
        (p_edfi_doc->>'birthOrder')::INT,
        p_document.CreatedAt,
        p_document.LastModifiedAt,
        p_document.LastModifiedTraceId
    )
    ON CONFLICT (DocumentPartitionKey, DocumentId) DO UPDATE
    SET 
        StudentUniqueId = EXCLUDED.StudentUniqueId,
        FirstName = EXCLUDED.FirstName,
        MiddleName = EXCLUDED.MiddleName,
        LastSurname = EXCLUDED.LastSurname,
        -- ... other fields ...
        LastModifiedAt = EXCLUDED.LastModifiedAt,
        LastModifiedTraceId = EXCLUDED.LastModifiedTraceId;
    
    -- Delete existing addresses (for simplicity in updates)
    DELETE FROM edfi.StudentAddress 
    WHERE StudentDocumentPartitionKey = p_document.DocumentPartitionKey 
      AND StudentDocumentId = p_document.Id;
    
    -- Insert addresses
    v_sequence := 0;
    FOR v_address IN SELECT * FROM jsonb_array_elements(p_edfi_doc->'addresses')
    LOOP
        INSERT INTO edfi.StudentAddress (
            StudentDocumentId,
            StudentDocumentPartitionKey,
            AddressTypeDescriptorId,
            StreetNumberName,
            ApartmentRoomSuiteNumber,
            BuildingSiteNumber,
            City,
            StateAbbreviationDescriptorId,
            PostalCode,
            NameOfCounty,
            CountyFIPSCode,
            CountryDescriptorId,
            Latitude,
            Longitude,
            LocaleDescriptorId,
            BeginDate,
            EndDate,
            SequenceNumber
        ) VALUES (
            p_document.Id,
            p_document.DocumentPartitionKey,
            dms.get_descriptor_id(v_address->>'addressTypeDescriptor'),
            v_address->>'streetNumberName',
            v_address->>'apartmentRoomSuiteNumber',
            v_address->>'buildingSiteNumber',
            v_address->>'city',
            dms.get_descriptor_id(v_address->>'stateAbbreviationDescriptor'),
            v_address->>'postalCode',
            v_address->>'nameOfCounty',
            v_address->>'countyFIPSCode',
            dms.get_descriptor_id(v_address->>'countryDescriptor'),
            v_address->>'latitude',
            v_address->>'longitude',
            dms.get_descriptor_id(v_address->>'localeDescriptor'),
            CASE WHEN v_address->'periods' IS NOT NULL 
                 THEN (v_address->'periods'->0->>'beginDate')::DATE 
                 ELSE NULL END,
            CASE WHEN v_address->'periods' IS NOT NULL 
                 THEN (v_address->'periods'->0->>'endDate')::DATE 
                 ELSE NULL END,
            v_sequence
        );
        v_sequence := v_sequence + 1;
    END LOOP;
    
    -- Dynamically call registered extension flattening functions
    FOR v_extension_function IN 
        SELECT ef.flattening_function, ef.extension_name
        FROM dms.extension_flattening_registry ef
        JOIN dms.extension_registry er ON ef.extension_name = er.extension_name
        WHERE ef.core_resource_name = 'students'
          AND er.is_enabled = true
        ORDER BY ef.priority DESC
    LOOP
        RAISE DEBUG 'Calling extension function % for %', 
            v_extension_function.flattening_function, 
            v_extension_function.extension_name;
        
        BEGIN
            EXECUTE format('SELECT %s($1, $2)', v_extension_function.flattening_function) 
            USING p_document, p_edfi_doc;
        EXCEPTION WHEN OTHERS THEN
            -- Log error but continue processing other extensions
            RAISE WARNING 'Error in extension % flattening: %', 
                v_extension_function.extension_name, SQLERRM;
        END;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

### Extension Flattening Function Examples

```sql
-- TPDM Student Extension Flattening (generated by MetaEd)
CREATE OR REPLACE FUNCTION dms.flatten_tpdm_student_extension(
    p_document RECORD,
    p_edfi_doc JSONB
) RETURNS VOID AS $$
DECLARE
    v_extension_data JSONB;
BEGIN
    -- Check if document has TPDM extension
    IF p_edfi_doc->'_ext' ? 'tpdm' THEN
        v_extension_data := p_edfi_doc->'_ext'->'tpdm';
        
        INSERT INTO tpdm.StudentExtension (
            StudentDocumentId,
            StudentDocumentPartitionKey,
            GenderDescriptorId,
            HispanicLatinoEthnicity,
            OldEthnicityDescriptorId,
            SexDescriptorId
        ) VALUES (
            p_document.Id,
            p_document.DocumentPartitionKey,
            dms.get_descriptor_id(v_extension_data->>'genderDescriptor'),
            (v_extension_data->>'hispanicLatinoEthnicity')::BOOLEAN,
            dms.get_descriptor_id(v_extension_data->>'oldEthnicityDescriptor'),
            dms.get_descriptor_id(v_extension_data->>'sexDescriptor')
        )
        ON CONFLICT (StudentDocumentPartitionKey, StudentDocumentId) DO UPDATE
        SET 
            GenderDescriptorId = EXCLUDED.GenderDescriptorId,
            HispanicLatinoEthnicity = EXCLUDED.HispanicLatinoEthnicity,
            OldEthnicityDescriptorId = EXCLUDED.OldEthnicityDescriptorId,
            SexDescriptorId = EXCLUDED.SexDescriptorId;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- TPDM Candidate Resource Flattening (generated by MetaEd)
CREATE OR REPLACE FUNCTION dms.flatten_tpdm_candidate(
    p_document RECORD,
    p_edfi_doc JSONB
) RETURNS VOID AS $$
BEGIN
    INSERT INTO tpdm.Candidate (
        DocumentId,
        DocumentPartitionKey,
        DocumentUuid,
        CandidateIdentifier,
        FirstName,
        LastSurname,
        SexDescriptorId,
        BirthDate,
        HispanicLatinoEthnicity,
        EconomicDisadvantaged,
        FirstGenerationStudent,
        PersonId,
        CreatedAt,
        LastModifiedAt,
        LastModifiedTraceId
    ) VALUES (
        p_document.Id,
        p_document.DocumentPartitionKey,
        p_document.DocumentUuid,
        p_edfi_doc->>'candidateIdentifier',
        p_edfi_doc->>'firstName',
        p_edfi_doc->>'lastSurname',
        dms.get_descriptor_id(p_edfi_doc->>'sexDescriptor'),
        (p_edfi_doc->>'birthDate')::DATE,
        (p_edfi_doc->>'hispanicLatinoEthnicity')::BOOLEAN,
        (p_edfi_doc->>'economicDisadvantaged')::BOOLEAN,
        (p_edfi_doc->>'firstGenerationStudent')::BOOLEAN,
        p_edfi_doc->>'personId',
        p_document.CreatedAt,
        p_document.LastModifiedAt,
        p_document.LastModifiedTraceId
    )
    ON CONFLICT (DocumentPartitionKey, DocumentId) DO UPDATE
    SET 
        CandidateIdentifier = EXCLUDED.CandidateIdentifier,
        FirstName = EXCLUDED.FirstName,
        LastSurname = EXCLUDED.LastSurname,
        -- ... other fields ...
        LastModifiedAt = EXCLUDED.LastModifiedAt,
        LastModifiedTraceId = EXCLUDED.LastModifiedTraceId;
    
    -- Call any registered extensions for tpdm_candidate
    PERFORM dms.call_resource_extensions('tpdm_candidate', p_document, p_edfi_doc);
END;
$$ LANGUAGE plpgsql;
```

### Helper Function for Extension Calls

```sql
CREATE OR REPLACE FUNCTION dms.call_resource_extensions(
    p_resource_name VARCHAR,
    p_document RECORD,
    p_edfi_doc JSONB
) RETURNS VOID AS $$
DECLARE
    v_extension_function RECORD;
BEGIN
    -- Call all registered extensions for this resource
    FOR v_extension_function IN 
        SELECT ef.flattening_function, ef.extension_name
        FROM dms.extension_flattening_registry ef
        JOIN dms.extension_registry er ON ef.extension_name = er.extension_name
        WHERE ef.core_resource_name = p_resource_name
          AND er.is_enabled = true
        ORDER BY ef.priority DESC
    LOOP
        BEGIN
            EXECUTE format('SELECT %s($1, $2)', v_extension_function.flattening_function) 
            USING p_document, p_edfi_doc;
        EXCEPTION WHEN OTHERS THEN
            RAISE WARNING 'Error in extension % flattening for %: %', 
                v_extension_function.extension_name, p_resource_name, SQLERRM;
        END;
    END LOOP;
END;
$$ LANGUAGE plpgsql;
```

### Descriptor Resolution Function

```sql
CREATE OR REPLACE FUNCTION dms.get_descriptor_id(
    p_descriptor_uri VARCHAR
) RETURNS INT AS $$
DECLARE
    v_namespace VARCHAR(255);
    v_code_value VARCHAR(50);
    v_hash_index INT;
    v_descriptor_id INT;
BEGIN
    IF p_descriptor_uri IS NULL THEN
        RETURN NULL;
    END IF;
    
    -- Parse URI format: "uri://namespace#codeValue"
    v_hash_index := POSITION('#' IN p_descriptor_uri);
    IF v_hash_index = 0 THEN
        RAISE EXCEPTION 'Invalid descriptor URI format: %', p_descriptor_uri;
    END IF;
    
    v_namespace := SUBSTRING(p_descriptor_uri FROM 1 FOR v_hash_index - 1);
    v_code_value := SUBSTRING(p_descriptor_uri FROM v_hash_index + 1);
    
    -- Look up or create descriptor
    SELECT DescriptorId INTO v_descriptor_id
    FROM edfi.Descriptor
    WHERE Namespace = v_namespace AND CodeValue = v_code_value;
    
    IF v_descriptor_id IS NULL THEN
        -- Create new descriptor entry
        INSERT INTO edfi.Descriptor (Namespace, CodeValue, ShortDescription)
        VALUES (v_namespace, v_code_value, v_code_value)
        RETURNING DescriptorId INTO v_descriptor_id;
    END IF;
    
    RETURN v_descriptor_id;
END;
$$ LANGUAGE plpgsql;
```

## Extension Registration Examples

### Core Ed-Fi Registration (generated by MetaEd)

```sql
-- Register core Ed-Fi resources
INSERT INTO dms.resource_flattening_registry 
(resource_name, extension_name, flattening_function, target_table, priority)
VALUES 
('students', NULL, 'dms.flatten_student', 'edfi.Student', 100),
('schools', NULL, 'dms.flatten_school', 'edfi.School', 100),
('studentSchoolAssociations', NULL, 'dms.flatten_student_school_association', 'edfi.StudentSchoolAssociation', 100);
```

### TPDM Extension Registration (generated by MetaEd)

```sql
-- Register TPDM extension with its schema
INSERT INTO dms.extension_registry (extension_name, schema_name)
VALUES ('tpdm', 'tpdm');

-- Register TPDM's new resources
INSERT INTO dms.resource_flattening_registry 
(resource_name, extension_name, flattening_function, target_table, priority)
VALUES 
('candidates', 'tpdm', 'dms.flatten_tpdm_candidate', 'tpdm.Candidate', 100),
('candidateEducatorPreparationProgramAssociations', 'tpdm', 
 'dms.flatten_tpdm_candidate_educator_preparation_program_association', 
 'tpdm.CandidateEducatorPreparationProgramAssociation', 100);

-- Register TPDM's extensions to core resources
INSERT INTO dms.extension_flattening_registry
(core_resource_name, extension_name, flattening_function, priority)
VALUES 
('students', 'tpdm', 'dms.flatten_tpdm_student_extension', 100),
('schools', 'tpdm', 'dms.flatten_tpdm_school_extension', 100);
```

### Sample Extension Registration (generated by MetaEd)

```sql
-- Register Sample extension with its schema
INSERT INTO dms.extension_registry (extension_name, schema_name)
VALUES ('sample', 'sample');

-- Register Sample's new resources
INSERT INTO dms.resource_flattening_registry 
(resource_name, extension_name, flattening_function, target_table, priority)
VALUES 
('pets', 'sample', 'dms.flatten_sample_pet', 'sample.Pet', 100);

-- Register Sample's extensions to core resources
INSERT INTO dms.extension_flattening_registry
(core_resource_name, extension_name, flattening_function, priority)
VALUES 
('students', 'sample', 'dms.flatten_sample_student_extension', 100);
```

## Trigger-Based Synchronization

### Document Insert/Update Trigger

```sql
CREATE OR REPLACE FUNCTION dms.document_flattening_trigger() 
RETURNS TRIGGER AS $$
BEGIN
    -- Flatten the document asynchronously or synchronously based on configuration
    IF current_setting('dms.async_flattening', true) = 'true' THEN
        -- Queue for async processing
        INSERT INTO dms.flattening_queue (
            DocumentId, 
            DocumentPartitionKey, 
            ResourceName,
            Operation,
            QueuedAt
        ) VALUES (
            NEW.Id,
            NEW.DocumentPartitionKey,
            NEW.ResourceName,
            TG_OP,
            NOW()
        );
    ELSE
        -- Synchronous flattening
        PERFORM dms.flatten_document(NEW.Id, NEW.DocumentPartitionKey);
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER document_after_insert_update
AFTER INSERT OR UPDATE ON dms.Document
FOR EACH ROW
EXECUTE FUNCTION dms.document_flattening_trigger();
```

### Document Delete Trigger

```sql
CREATE OR REPLACE FUNCTION dms.document_delete_trigger() 
RETURNS TRIGGER AS $$
BEGIN
    -- Cascading deletes handle the relational table cleanup
    -- Log the deletion if needed
    INSERT INTO dms.deletion_log (
        DocumentId,
        DocumentPartitionKey,
        ResourceName,
        DeletedAt,
        DocumentUuid
    ) VALUES (
        OLD.Id,
        OLD.DocumentPartitionKey,
        OLD.ResourceName,
        NOW(),
        OLD.DocumentUuid
    );
    
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER document_before_delete
BEFORE DELETE ON dms.Document
FOR EACH ROW
EXECUTE FUNCTION dms.document_delete_trigger();
```

## Performance Optimizations

### 1. Batch Processing Queue

```sql
CREATE TABLE dms.flattening_queue (
    Id BIGSERIAL PRIMARY KEY,
    DocumentId BIGINT NOT NULL,
    DocumentPartitionKey SMALLINT NOT NULL,
    ResourceName VARCHAR(256) NOT NULL,
    Operation VARCHAR(10) NOT NULL,
    QueuedAt TIMESTAMP NOT NULL,
    ProcessedAt TIMESTAMP NULL,
    Status VARCHAR(20) DEFAULT 'pending',
    ErrorMessage TEXT NULL
);

CREATE INDEX IX_flattening_queue_pending 
ON dms.flattening_queue(Status) 
WHERE Status = 'pending';
```

### 2. Parallel Processing

```sql
CREATE OR REPLACE FUNCTION dms.process_flattening_queue_batch(
    p_batch_size INT DEFAULT 100
) RETURNS INT AS $$
DECLARE
    v_processed INT := 0;
    v_queue_record RECORD;
BEGIN
    -- Process a batch of pending items
    FOR v_queue_record IN 
        SELECT * FROM dms.flattening_queue
        WHERE Status = 'pending'
        ORDER BY QueuedAt
        LIMIT p_batch_size
        FOR UPDATE SKIP LOCKED
    LOOP
        BEGIN
            -- Update status to processing
            UPDATE dms.flattening_queue
            SET Status = 'processing'
            WHERE Id = v_queue_record.Id;
            
            -- Perform flattening
            PERFORM dms.flatten_document(
                v_queue_record.DocumentId, 
                v_queue_record.DocumentPartitionKey
            );
            
            -- Mark as completed
            UPDATE dms.flattening_queue
            SET Status = 'completed',
                ProcessedAt = NOW()
            WHERE Id = v_queue_record.Id;
            
            v_processed := v_processed + 1;
            
        EXCEPTION WHEN OTHERS THEN
            -- Log error and continue
            UPDATE dms.flattening_queue
            SET Status = 'error',
                ProcessedAt = NOW(),
                ErrorMessage = SQLERRM
            WHERE Id = v_queue_record.Id;
        END;
    END LOOP;
    
    RETURN v_processed;
END;
$$ LANGUAGE plpgsql;
```

## Testing Strategy

### 1. Unit Tests

```sql
-- Test individual flattening functions
CREATE OR REPLACE FUNCTION dms_test.test_student_flattening() 
RETURNS VOID AS $$
DECLARE
    v_doc_id BIGINT;
    v_student_id VARCHAR(32) := 'TEST' || floor(random() * 1000000)::text;
    v_student_json JSONB;
BEGIN
    -- Create test student JSON
    v_student_json := jsonb_build_object(
        'studentUniqueId', v_student_id,
        'firstName', 'Test',
        'lastName', 'Student',
        'birthDate', '2010-01-01',
        'addresses', jsonb_build_array(
            jsonb_build_object(
                'addressTypeDescriptor', 'uri://ed-fi.org/AddressTypeDescriptor#Home',
                'streetNumberName', '123 Main St',
                'city', 'TestCity',
                'stateAbbreviationDescriptor', 'uri://ed-fi.org/StateAbbreviationDescriptor#TX',
                'postalCode', '12345'
            )
        )
    );
    
    -- Insert test document
    INSERT INTO dms.Document (
        DocumentPartitionKey,
        DocumentUuid,
        ResourceName,
        ResourceVersion,
        IsDescriptor,
        ProjectName,
        EdfiDoc,
        SecurityElements,
        LastModifiedTraceId
    ) VALUES (
        0,
        gen_random_uuid(),
        'students',
        '5.1.0',
        false,
        'Ed-Fi',
        v_student_json,
        '{}',
        'unit-test'
    ) RETURNING Id INTO v_doc_id;
    
    -- Wait for trigger processing
    PERFORM pg_sleep(0.1);
    
    -- Verify student record
    ASSERT EXISTS(SELECT 1 FROM edfi.Student WHERE StudentUniqueId = v_student_id), 
           'Student not flattened';
    ASSERT (SELECT FirstName FROM edfi.Student WHERE StudentUniqueId = v_student_id) = 'Test',
           'Student FirstName incorrect';
    
    -- Verify address record
    ASSERT EXISTS(
        SELECT 1 FROM edfi.StudentAddress 
        WHERE StudentDocumentId = v_doc_id 
          AND StreetNumberName = '123 Main St'
    ), 'Student address not flattened';
    
    -- Cleanup
    DELETE FROM dms.Document WHERE Id = v_doc_id;
    
    RAISE NOTICE 'test_student_flattening: PASSED';
END;
$$ LANGUAGE plpgsql;
```

### 2. Integration Tests

```sql
-- Test full document lifecycle with extensions
CREATE OR REPLACE FUNCTION dms_test.test_document_lifecycle() 
RETURNS VOID AS $$
DECLARE
    v_doc_id BIGINT;
    v_student_id VARCHAR(32) := 'LIFECYCLE' || floor(random() * 1000000)::text;
    v_student_json JSONB;
BEGIN
    -- Create student with extension
    v_student_json := jsonb_build_object(
        'studentUniqueId', v_student_id,
        'firstName', 'Integration',
        'lastName', 'Test',
        'birthDate', '2010-01-01',
        '_ext', jsonb_build_object(
            'tpdm', jsonb_build_object(
                'genderDescriptor', 'uri://ed-fi.org/tpdm/GenderDescriptor#Male',
                'hispanicLatinoEthnicity', true
            )
        )
    );
    
    -- Test INSERT
    INSERT INTO dms.Document (
        DocumentPartitionKey,
        DocumentUuid,
        ResourceName,
        ResourceVersion,
        IsDescriptor,
        ProjectName,
        EdfiDoc,
        SecurityElements,
        LastModifiedTraceId
    ) VALUES (
        0,
        gen_random_uuid(),
        'students',
        '5.1.0',
        false,
        'Ed-Fi',
        v_student_json,
        '{}',
        'integration-test'
    ) RETURNING Id INTO v_doc_id;
    
    PERFORM pg_sleep(0.1);
    ASSERT EXISTS(SELECT 1 FROM edfi.Student WHERE StudentUniqueId = v_student_id), 
           'Student not created';
    ASSERT EXISTS(SELECT 1 FROM tpdm.StudentExtension WHERE StudentDocumentId = v_doc_id), 
           'TPDM extension not created';
    
    -- Test UPDATE
    v_student_json := jsonb_set(v_student_json, '{firstName}', '"Updated"');
    UPDATE dms.Document 
    SET EdfiDoc = v_student_json,
        LastModifiedAt = NOW(),
        LastModifiedTraceId = 'update-test'
    WHERE Id = v_doc_id;
    
    PERFORM pg_sleep(0.1);
    ASSERT (SELECT FirstName FROM edfi.Student WHERE StudentUniqueId = v_student_id) = 'Updated',
           'Student not updated';
    
    -- Test DELETE
    DELETE FROM dms.Document WHERE Id = v_doc_id AND DocumentPartitionKey = 0;
    
    PERFORM pg_sleep(0.1);
    ASSERT NOT EXISTS(SELECT 1 FROM edfi.Student WHERE StudentUniqueId = v_student_id), 
           'Student not deleted after document delete';
    ASSERT NOT EXISTS(SELECT 1 FROM tpdm.StudentExtension WHERE StudentDocumentId = v_doc_id), 
           'TPDM extension not deleted after document delete';
    
    RAISE NOTICE 'test_document_lifecycle: PASSED';
END;
$$ LANGUAGE plpgsql;
```

### 3. Performance Tests

```sql
CREATE OR REPLACE FUNCTION dms_test.test_bulk_flattening_performance(
    p_record_count INT DEFAULT 1000
) RETURNS TABLE(
    operation VARCHAR,
    duration INTERVAL,
    records_per_second NUMERIC
) AS $$
DECLARE
    v_start_time TIMESTAMP;
    v_end_time TIMESTAMP;
    v_duration INTERVAL;
    i INT;
BEGIN
    -- Test bulk insert performance
    v_start_time := clock_timestamp();
    
    FOR i IN 1..p_record_count LOOP
        INSERT INTO dms.Document (
            DocumentPartitionKey,
            DocumentUuid,
            ResourceName,
            ResourceVersion,
            IsDescriptor,
            ProjectName,
            EdfiDoc,
            SecurityElements,
            LastModifiedTraceId
        ) VALUES (
            i % 16, -- Distribute across partitions
            gen_random_uuid(),
            'students',
            '5.1.0',
            false,
            'Ed-Fi',
            jsonb_build_object(
                'studentUniqueId', 'PERF' || LPAD(i::text, 6, '0'),
                'firstName', 'Perf',
                'lastName', 'Test' || i,
                'birthDate', '2010-01-01',
                '_ext', jsonb_build_object(
                    'sample', jsonb_build_object(
                        'medicalRecordNumber', 'MRN' || i
                    )
                )
            ),
            '{}',
            'perf-test'
        );
    END LOOP;
    
    v_end_time := clock_timestamp();
    v_duration := v_end_time - v_start_time;
    
    RETURN QUERY
    SELECT 
        'Bulk Insert'::VARCHAR,
        v_duration,
        ROUND(p_record_count / EXTRACT(epoch FROM v_duration), 2);
    
    -- Process flattening queue if async
    IF current_setting('dms.async_flattening', true) = 'true' THEN
        v_start_time := clock_timestamp();
        
        WHILE EXISTS(SELECT 1 FROM dms.flattening_queue WHERE Status = 'pending') LOOP
            PERFORM dms.process_flattening_queue_batch(100);
        END LOOP;
        
        v_end_time := clock_timestamp();
        v_duration := v_end_time - v_start_time;
        
        RETURN QUERY
        SELECT 
            'Queue Processing'::VARCHAR,
            v_duration,
            ROUND(p_record_count / EXTRACT(epoch FROM v_duration), 2);
    END IF;
    
    -- Cleanup
    DELETE FROM dms.Document 
    WHERE ResourceName = 'students' 
      AND EdfiDoc->>'lastName' LIKE 'Test%';
END;
$$ LANGUAGE plpgsql;
```

### 4. Data Validation Tests

```sql
CREATE OR REPLACE FUNCTION dms_test.validate_flattening_accuracy() 
RETURNS TABLE(
    resource_name VARCHAR,
    document_count BIGINT,
    flattened_count BIGINT,
    discrepancy BIGINT
) AS $$
BEGIN
    -- Compare document counts with flattened record counts
    RETURN QUERY
    WITH doc_counts AS (
        SELECT 
            ResourceName,
            COUNT(*) as doc_count
        FROM dms.Document
        WHERE NOT IsDescriptor
        GROUP BY ResourceName
    ),
    flat_counts AS (
        SELECT 
            'students' as ResourceName,
            COUNT(DISTINCT DocumentId) as flat_count
        FROM edfi.Student
        UNION ALL
        SELECT 
            'schools',
            COUNT(DISTINCT DocumentId)
        FROM edfi.School
        UNION ALL
        SELECT 
            'studentSchoolAssociations',
            COUNT(DISTINCT DocumentId)
        FROM edfi.StudentSchoolAssociation
    )
    SELECT 
        d.ResourceName,
        d.doc_count,
        COALESCE(f.flat_count, 0) as flattened_count,
        d.doc_count - COALESCE(f.flat_count, 0) as discrepancy
    FROM doc_counts d
    LEFT JOIN flat_counts f ON d.ResourceName = f.ResourceName
    WHERE d.doc_count != COALESCE(f.flat_count, 0);
END;
$$ LANGUAGE plpgsql;
```

### 5. Registry Configuration Tests

```sql
-- Test extension registration
CREATE OR REPLACE FUNCTION dms_test.test_extension_registration() 
RETURNS VOID AS $$
BEGIN
    -- Register test extension
    INSERT INTO dms.extension_registry (extension_name, schema_name, is_enabled)
    VALUES ('test_ext', 'test_ext', true);
    
    -- Register test resource
    INSERT INTO dms.resource_flattening_registry 
    (resource_name, extension_name, flattening_function, target_table)
    VALUES ('testResources', 'test_ext', 'dms.flatten_test_resource', 'test_ext.Resource');
    
    -- Verify registration
    ASSERT EXISTS(
        SELECT 1 FROM dms.resource_flattening_registry
        WHERE resource_name = 'testResources' 
          AND extension_name = 'test_ext'
    ), 'Test resource not registered';
    
    -- Test disabling extension
    UPDATE dms.extension_registry 
    SET is_enabled = false 
    WHERE extension_name = 'test_ext';
    
    -- Verify disabled extension resources are not processed
    -- (Additional test logic here)
    
    -- Cleanup
    DELETE FROM dms.resource_flattening_registry WHERE extension_name = 'test_ext';
    DELETE FROM dms.extension_registry WHERE extension_name = 'test_ext';
    
    RAISE NOTICE 'test_extension_registration: PASSED';
END;
$$ LANGUAGE plpgsql;
```

### 6. Dynamic Flattening Tests

```sql
-- Test dynamic function resolution
CREATE OR REPLACE FUNCTION dms_test.test_dynamic_flattening() 
RETURNS VOID AS $$
DECLARE
    v_doc_id BIGINT;
    v_test_resource JSONB;
BEGIN
    -- Create test schema
    CREATE SCHEMA IF NOT EXISTS test_dynamic;
    
    -- Create test flattening function
    CREATE OR REPLACE FUNCTION dms.flatten_test_dynamic_resource(
        p_document RECORD,
        p_edfi_doc JSONB
    ) RETURNS VOID AS $$
    BEGIN
        RAISE NOTICE 'Test flattening function called for %', p_edfi_doc->>'id';
    END;
    $$ LANGUAGE plpgsql;
    
    -- Register the function
    INSERT INTO dms.resource_flattening_registry 
    (resource_name, extension_name, flattening_function, target_table)
    VALUES ('testDynamicResources', NULL, 'dms.flatten_test_dynamic_resource', 'test_dynamic.TestDynamic');
    
    -- Create test document
    v_test_resource := jsonb_build_object(
        'id', 'TEST123',
        'name', 'Test Resource'
    );
    
    INSERT INTO dms.Document (
        DocumentPartitionKey,
        DocumentUuid,
        ResourceName,
        ResourceVersion,
        IsDescriptor,
        ProjectName,
        EdfiDoc,
        SecurityElements,
        LastModifiedTraceId
    ) VALUES (
        0,
        gen_random_uuid(),
        'testDynamicResources',
        '1.0.0',
        false,
        'Test',
        v_test_resource,
        '{}'::jsonb,
        'test-dynamic'
    ) RETURNING Id INTO v_doc_id;
    
    -- Execute flattening - should dynamically find and call the function
    PERFORM dms.flatten_document(v_doc_id, 0);
    
    -- Cleanup
    DELETE FROM dms.Document WHERE Id = v_doc_id;
    DELETE FROM dms.resource_flattening_registry WHERE resource_name = 'testDynamicResources';
    DROP FUNCTION dms.flatten_test_dynamic_resource;
    DROP SCHEMA test_dynamic CASCADE;
    
    RAISE NOTICE 'test_dynamic_flattening: PASSED';
END;
$$ LANGUAGE plpgsql;
```

### 7. Extension Priority Tests

```sql
-- Test extension priority handling
CREATE OR REPLACE FUNCTION dms_test.test_extension_priority() 
RETURNS VOID AS $$
BEGIN
    -- Create test schemas
    CREATE SCHEMA IF NOT EXISTS ext_a;
    CREATE SCHEMA IF NOT EXISTS ext_b;
    
    -- Register two extensions that handle the same resource
    INSERT INTO dms.extension_registry (extension_name, schema_name, priority)
    VALUES 
    ('ext_a', 'ext_a', 100),
    ('ext_b', 'ext_b', 200); -- Higher priority
    
    -- Register both for same resource
    INSERT INTO dms.resource_flattening_registry 
    (resource_name, extension_name, flattening_function, target_table, priority)
    VALUES 
    ('priorityTestResources', 'ext_a', 'dms.flatten_ext_a_resource', 'ext_a.Resource', 100),
    ('priorityTestResources', 'ext_b', 'dms.flatten_ext_b_resource', 'ext_b.Resource', 100);
    
    -- Verify ext_b is chosen due to extension priority
    ASSERT (
        SELECT extension_name 
        FROM dms.resource_flattening_registry rf
        JOIN dms.extension_registry er ON rf.extension_name = er.extension_name
        WHERE rf.resource_name = 'priorityTestResources'
          AND er.is_enabled = true
        ORDER BY er.priority DESC
        LIMIT 1
    ) = 'ext_b', 'Wrong extension chosen based on priority';
    
    -- Cleanup
    DELETE FROM dms.resource_flattening_registry WHERE resource_name = 'priorityTestResources';
    DELETE FROM dms.extension_registry WHERE extension_name IN ('ext_a', 'ext_b');
    DROP SCHEMA ext_a CASCADE;
    DROP SCHEMA ext_b CASCADE;
    
    RAISE NOTICE 'test_extension_priority: PASSED';
END;
$$ LANGUAGE plpgsql;
```

### 8. Table Name Hash Tests

```sql
-- Test table name hashing for long names
CREATE OR REPLACE FUNCTION dms_test.test_table_name_hashing() 
RETURNS VOID AS $$
DECLARE
    v_long_name VARCHAR := 'VeryLongTableNameThatExceedsPostgreSQLSixtyThreeCharacterLimit_Extended';
    v_resolved_name VARCHAR;
BEGIN
    -- Test name resolution
    v_resolved_name := dms.resolve_table_name('test', v_long_name);
    
    -- Verify name is within limit
    ASSERT LENGTH(v_resolved_name) <= 63, 'Resolved name exceeds 63 characters';
    
    -- Verify hash suffix is added
    ASSERT v_resolved_name LIKE '%_%', 'Hash suffix not added';
    
    -- Verify mapping is stored
    ASSERT EXISTS(
        SELECT 1 FROM dms.table_name_registry
        WHERE logical_table_name = v_long_name
          AND schema_name = 'test'
    ), 'Name mapping not stored';
    
    -- Test retrieval of same name returns same result
    ASSERT dms.resolve_table_name('test', v_long_name) = v_resolved_name,
           'Inconsistent name resolution';
    
    -- Cleanup
    DELETE FROM dms.table_name_registry WHERE logical_table_name = v_long_name;
    
    RAISE NOTICE 'test_table_name_hashing: PASSED';
END;
$$ LANGUAGE plpgsql;
```

## Migration Strategy

### Initial Population with Extensions

```sql
CREATE OR REPLACE FUNCTION dms.initial_flattening_migration(
    p_resource_name VARCHAR DEFAULT NULL,
    p_batch_size INT DEFAULT 1000
) RETURNS TABLE(
    resource_name VARCHAR,
    total_processed BIGINT,
    duration INTERVAL
) AS $$
DECLARE
    v_start_time TIMESTAMP;
    v_processed BIGINT := 0;
    v_batch RECORD;
BEGIN
    v_start_time := clock_timestamp();
    
    -- Ensure registries are populated
    IF NOT EXISTS (SELECT 1 FROM dms.resource_flattening_registry) THEN
        RAISE EXCEPTION 'Resource flattening registry is empty. Run extension registration scripts first.';
    END IF;
    
    -- Disable triggers during migration
    ALTER TABLE dms.Document DISABLE TRIGGER document_after_insert_update;
    
    -- Process documents in batches
    FOR v_batch IN 
        SELECT 
            d.ResourceName,
            COUNT(*) as batch_count
        FROM dms.Document d
        WHERE NOT d.IsDescriptor
          AND (p_resource_name IS NULL OR d.ResourceName = p_resource_name)
          AND EXISTS (
              -- Only process resources that have registered handlers
              SELECT 1 FROM dms.resource_flattening_registry rf
              LEFT JOIN dms.extension_registry er ON rf.extension_name = er.extension_name
              WHERE rf.resource_name = d.ResourceName
                AND (rf.extension_name IS NULL OR er.is_enabled = true)
          )
        GROUP BY d.ResourceName
    LOOP
        -- Queue all documents for this resource
        INSERT INTO dms.flattening_queue (
            DocumentId,
            DocumentPartitionKey,
            ResourceName,
            Operation,
            QueuedAt
        )
        SELECT 
            Id,
            DocumentPartitionKey,
            ResourceName,
            'MIGRATE',
            NOW()
        FROM dms.Document
        WHERE ResourceName = v_batch.ResourceName
          AND NOT IsDescriptor;
        
        -- Process queue
        WHILE EXISTS(
            SELECT 1 FROM dms.flattening_queue 
            WHERE Status = 'pending' 
              AND ResourceName = v_batch.ResourceName
        ) LOOP
            PERFORM dms.process_flattening_queue_batch(p_batch_size);
        END LOOP;
        
        v_processed := v_processed + v_batch.batch_count;
        
        RETURN QUERY
        SELECT 
            v_batch.ResourceName,
            v_batch.batch_count,
            clock_timestamp() - v_start_time;
    END LOOP;
    
    -- Re-enable triggers
    ALTER TABLE dms.Document ENABLE TRIGGER document_after_insert_update;
END;
$$ LANGUAGE plpgsql;
```

## Work Division for Multiple Agents

### Agent 1: Core Infrastructure (Database Architect)
**Responsibilities:**
- Create schema architecture (dms, edfi, extension schemas)
- Create extension registry tables
- Design core table DDL scripts
- Implement partitioning strategy
- Create indexes and constraints
- Implement descriptor management
- Set up table name resolution system

**Deliverables:**
1. Schema creation scripts
2. Extension registry DDL
3. Core table DDL scripts (in edfi schema)
4. Partitioning setup script
5. Index creation script
6. Descriptor management functions
7. Table name resolution functions

### Agent 2: Core Flattening Logic (Backend Developer)
**Responsibilities:**
- Implement dynamic flatten_document function
- Create core resource flattening functions
- Handle reference resolution
- Implement array/collection handling
- Create helper functions for extensions

**Deliverables:**
1. Dynamic `flatten_document` function
2. Core resource flattening functions (Student, School, etc.)
3. Reference resolution utilities
4. Array handling procedures
5. Extension helper functions

### Agent 3: Extension Framework (Extension Developer)
**Responsibilities:**
- Design extension registration process
- Create extension flattening templates
- Implement dynamic function resolution
- Handle extension priorities
- Create extension isolation

**Deliverables:**
1. Extension registration procedures
2. Extension flattening templates
3. Dynamic function resolution logic
4. Priority handling system
5. Extension isolation mechanisms

### Agent 4: MetaEd Integration (MetaEd Developer)
**Responsibilities:**
- Generate extension table DDL with proper schemas
- Generate flattening functions
- Generate registration scripts
- Handle constraint name length limits (63 chars) with hash suffixes
- Create extension metadata model
- Document MetaEd extension process

**Deliverables:**
1. Extension DDL generation templates
2. Flattening function generators
3. Registration script generators
4. Extension metadata model
5. MetaEd extension documentation

### Agent 5: Testing & Validation (QA Engineer)
**Responsibilities:**
- Test extension registration
- Test dynamic flattening
- Test extension priorities
- Test extension isolation
- Create extension test framework
- Test table name resolution

**Deliverables:**
1. Extension registration tests
2. Dynamic flattening tests
3. Priority handling tests
4. Extension isolation tests
5. Extension test framework
6. Table name hashing tests

### Agent 6: Migration & Deployment (DevOps Engineer)
**Responsibilities:**
- Create extension deployment procedures
- Handle extension versioning
- Monitor extension performance
- Create rollback procedures
- Document deployment process

**Deliverables:**
1. Extension deployment scripts
2. Extension versioning system
3. Performance monitoring
4. Rollback procedures
5. Deployment documentation

## Benefits of the Dynamic Extension System

1. **Zero Core Modifications**: New extensions require no changes to core flattening logic
2. **Schema Isolation**: Extensions use separate schemas, avoiding naming conflicts
3. **Configuration-Based**: Extensions enabled/disabled through registry
4. **Table Name Management**: Hash suffix handles long names transparently
5. **Priority Support**: Handle conflicts when multiple extensions modify same resource
6. **MetaEd Integration**: Fully generated by MetaEd, no manual coding
7. **Error Isolation**: Extension errors don't break core flattening
8. **Performance**: Only enabled extensions are processed
9. **Auditability**: Clear registry of what's installed and active

## Risk Mitigation

### Technical Risks

1. **Dynamic Function Execution**
   - **Risk**: SQL injection through function names
   - **Mitigation**: Validate function names, use schema qualification

2. **Extension Conflicts**
   - **Risk**: Multiple extensions modifying same data
   - **Mitigation**: Priority system, clear precedence rules

3. **Performance Impact**
   - **Risk**: Dynamic lookups slow down flattening
   - **Mitigation**: Cache registry lookups, optimize queries

4. **Table Name Collisions**
   - **Risk**: Hash collisions for shortened names
   - **Mitigation**: Include original name prefix, verify uniqueness

### Operational Risks

1. **Extension Versioning**
   - **Risk**: Incompatible extension versions
   - **Mitigation**: Version tracking in registry, compatibility checks

2. **Debugging Complexity**
   - **Risk**: Hard to trace dynamic execution
   - **Mitigation**: Comprehensive logging, debug mode

## Success Criteria

1. **Functional Requirements**
   - Core Ed-Fi resources flatten correctly to edfi schema
   - Extensions can be added without core changes
   - Extension resources flatten to their own schemas
   - Extension modifications to core resources work
   - Long table names handled transparently

2. **Performance Requirements**
   - Dynamic lookup adds < 5ms overhead
   - Extension flattening performs same as hardcoded
   - Parallel extension processing supported

3. **Quality Requirements**
   - 100% test coverage for extension framework
   - Clear error messages for missing registrations
   - Graceful handling of extension errors

## Conclusion

This design provides a fully extensible flattening system where extensions can be added at deployment time without modifying any core logic. The schema-based approach with dynamic function resolution ensures complete decoupling while maintaining performance and reliability. The hash suffix strategy handles long table names transparently. MetaEd generation of all artifacts ensures consistency and reduces manual errors.